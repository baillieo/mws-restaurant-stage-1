{"version":3,"names":[],"mappings":"","sources":["dbhelper.js"],"sourcesContent":["\r\n// idb library\r\n\"use strict\";!function(){function e(e){return new Promise(function(t,n){e.onsuccess=function(){t(e.result)},e.onerror=function(){n(e.error)}})}function t(t,n,o){var r,i=new Promise(function(i,u){e(r=t[n].apply(t,o)).then(i,u)});return i.request=r,i}function n(e,t,n){n.forEach(function(n){Object.defineProperty(e.prototype,n,{get:function(){return this[t][n]},set:function(e){this[t][n]=e}})})}function o(e,n,o,r){r.forEach(function(r){r in o.prototype&&(e.prototype[r]=function(){return t(this[n],r,arguments)})})}function r(e,t,n,o){o.forEach(function(o){o in n.prototype&&(e.prototype[o]=function(){return this[t][o].apply(this[t],arguments)})})}function i(e,n,o,r){r.forEach(function(r){r in o.prototype&&(e.prototype[r]=function(){return e=this[n],(o=t(e,r,arguments)).then(function(e){if(e)return new c(e,o.request)});var e,o})})}function u(e){this._index=e}function c(e,t){this._cursor=e,this._request=t}function s(e){this._store=e}function p(e){this._tx=e,this.complete=new Promise(function(t,n){e.oncomplete=function(){t()},e.onerror=function(){n(e.error)},e.onabort=function(){n(e.error)}})}function a(e,t,n){this._db=e,this.oldVersion=t,this.transaction=new p(n)}function f(e){this._db=e}n(u,\"_index\",[\"name\",\"keyPath\",\"multiEntry\",\"unique\"]),o(u,\"_index\",IDBIndex,[\"get\",\"getKey\",\"getAll\",\"getAllKeys\",\"count\"]),i(u,\"_index\",IDBIndex,[\"openCursor\",\"openKeyCursor\"]),n(c,\"_cursor\",[\"direction\",\"key\",\"primaryKey\",\"value\"]),o(c,\"_cursor\",IDBCursor,[\"update\",\"delete\"]),[\"advance\",\"continue\",\"continuePrimaryKey\"].forEach(function(t){t in IDBCursor.prototype&&(c.prototype[t]=function(){var n=this,o=arguments;return Promise.resolve().then(function(){return n._cursor[t].apply(n._cursor,o),e(n._request).then(function(e){if(e)return new c(e,n._request)})})})}),s.prototype.createIndex=function(){return new u(this._store.createIndex.apply(this._store,arguments))},s.prototype.index=function(){return new u(this._store.index.apply(this._store,arguments))},n(s,\"_store\",[\"name\",\"keyPath\",\"indexNames\",\"autoIncrement\"]),o(s,\"_store\",IDBObjectStore,[\"put\",\"add\",\"delete\",\"clear\",\"get\",\"getAll\",\"getKey\",\"getAllKeys\",\"count\"]),i(s,\"_store\",IDBObjectStore,[\"openCursor\",\"openKeyCursor\"]),r(s,\"_store\",IDBObjectStore,[\"deleteIndex\"]),p.prototype.objectStore=function(){return new s(this._tx.objectStore.apply(this._tx,arguments))},n(p,\"_tx\",[\"objectStoreNames\",\"mode\"]),r(p,\"_tx\",IDBTransaction,[\"abort\"]),a.prototype.createObjectStore=function(){return new s(this._db.createObjectStore.apply(this._db,arguments))},n(a,\"_db\",[\"name\",\"version\",\"objectStoreNames\"]),r(a,\"_db\",IDBDatabase,[\"deleteObjectStore\",\"close\"]),f.prototype.transaction=function(){return new p(this._db.transaction.apply(this._db,arguments))},n(f,\"_db\",[\"name\",\"version\",\"objectStoreNames\"]),r(f,\"_db\",IDBDatabase,[\"close\"]),[\"openCursor\",\"openKeyCursor\"].forEach(function(e){[s,u].forEach(function(t){e in t.prototype&&(t.prototype[e.replace(\"open\",\"iterate\")]=function(){var t,n=(t=arguments,Array.prototype.slice.call(t)),o=n[n.length-1],r=this._store||this._index,i=r[e].apply(r,n.slice(0,-1));i.onsuccess=function(){o(i.result)}})})}),[u,s].forEach(function(e){e.prototype.getAll||(e.prototype.getAll=function(e,t){var n=this,o=[];return new Promise(function(r){n.iterateCursor(e,function(e){e?(o.push(e.value),void 0===t||o.length!=t?e.continue():r(o)):r(o)})})})});var d={open:function(e,n,o){var r=t(indexedDB,\"open\",[e,n]),i=r.request;return i&&(i.onupgradeneeded=function(e){o&&o(new a(i.result,e.oldVersion,i.transaction))}),r.then(function(e){return new f(e)})},delete:function(e){return t(indexedDB,\"deleteDatabase\",[e])}};\"undefined\"!=typeof module?(module.exports=d,module.exports.default=module.exports):self.idb=d}();\r\n\r\n\r\n/**\r\n * Common database helper functions.\r\n */\r\n\r\n class DBHelper {\r\n\r\n\t/**\r\n\t * Database URL.\r\n\t * Change this to restaurants.json file location on your server.\r\n\t */\r\n\t static get DATABASE_URL() {\r\n\t\t// const port = 8000 // Change this to your server port\r\n\t\t// return `http://localhost:${port}/data/restaurants.json`;\r\n\r\n\t\t// AJX via fetch\r\n\t\tconst port = 1337 // Change this to your server port\r\n\t\treturn `http://localhost:${port}/`;\r\n\t}\r\n\t/**\r\n\t * Create indexedDb database\r\n\r\n\t */\r\n\t static get dbPromise(){\r\n\t \tif (!navigator.serviceWorker) {\r\n\t \t\treturn Promise.resolve();\r\n\t \t} else {\r\n\t \t\treturn idb.open('restaurants', 1, function (upgradeDb) {\r\n\t \t\t\tupgradeDb.createObjectStore('restaurant-data', { keyPath: 'id' });\r\n\t \t\t\tupgradeDb.createObjectStore('restaurant-reviews', { keyPath: 'id' });\r\n\t \t\t\tupgradeDb.createObjectStore('restaurant-reviews-offline', { keyPath: 'id' });\r\n\t \t\t});\r\n\t \t}\r\n\t }\r\n\r\n\r\n\t/**\r\n\t * Fetch all restaurants.\r\n\t */\r\n\t static fetchRestaurants(callback) {\r\n\t \tlet url = `${DBHelper.DATABASE_URL}restaurants`;\r\n\t\t// Try to pull data from indexedDb\r\n\t\tDBHelper.dbPromise.then(db => {\r\n\t\t\tconst tx = db.transaction('restaurant-data');\r\n\t\t\tconst objStore = tx.objectStore('restaurant-data');\r\n\r\n\t\t\t// If the indexedDb is empty send a network request and populate the indexedDb database\r\n\t\t\tobjStore.getAll().then(objects => {\r\n\t\t\t\tif(objects.length === 0) {\r\n\t\t\t\t\tfetch(url)\r\n\t\t\t\t\t.then(res => res.json()) \r\n\t\t\t\t\t.then(function(restaurants){ \r\n\t\t\t\t\t\trestaurants.filter(function(res){\r\n\t\t\t\t\t\t\tconst num = 10;\r\n\t\t\t\t\t\t\tif (res.id === 10) {\r\n\t\t\t\t\t\t\t\tfetch(`${DBHelper.DATABASE_URL}restaurants/10/?photograph=${num}`, {\r\n\t\t\t\t\t\t\t\t\tmethod: 'post'\r\n\t\t\t\t\t\t\t\t})\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t})\r\n\t\t\t\t\t\t// enable 'readwrite' to add objects to indexedDb \r\n\t\t\t\t\t\tconst tx = db.transaction('restaurant-data', 'readwrite');\r\n\t\t\t\t\t\tconst objStore = tx.objectStore('restaurant-data');\r\n\t\t\t\t\t\trestaurants.map(res => objStore.put(res));\r\n\t\t\t\t\t\t// return restaurant objects from network request\r\n\t\t\t\t\t\treturn callback(null, restaurants);\r\n\t\t\t\t\t}).catch(error => callback(error, null))\r\n\t\t\t\t} else {\r\n\t\t\t\t\t// return reswtaurant objects from indexedDb\r\n\t\t\t\t\treturn callback(null, objects)\r\n\t\t\t\t}\r\n\t\t\t});\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Fetch a restaurant by its ID.\r\n\t */\r\n\t static fetchRestaurantById(id, callback) {\r\n\t\t// fetch all restaurants with proper error handling.\r\n\t\tDBHelper.fetchRestaurants((error, restaurants) => {\r\n\t\t\tif (error) {\r\n\t\t\t\tcallback(error, null);\r\n\t\t\t} else {\r\n\t\t\t\tconst restaurant = restaurants.find(r => r.id == id);\r\n\t\t\t\tif (restaurant) { // Got the restaurant\r\n\t\t\t\t\tcallback(null, restaurant);\r\n\t\t\t\t} else { // Restaurant does not exist in the database\r\n\t\t\t\t\tcallback('Restaurant does not exist', null);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Fetch restaurants by a cuisine type with proper error handling.\r\n\t */\r\n\t static fetchRestaurantByCuisine(cuisine, callback) {\r\n\t\t// Fetch all restaurants  with proper error handling\r\n\t\tDBHelper.fetchRestaurants((error, restaurants) => {\r\n\t\t\tif (error) {\r\n\t\t\t\tcallback(error, null);\r\n\t\t\t} else {\r\n\t\t\t\t// Filter restaurants to have only given cuisine type\r\n\t\t\t\tconst results = restaurants.filter(r => r.cuisine_type == cuisine);\r\n\t\t\t\tcallback(null, results);\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Fetch restaurants by a neighborhood with proper error handling.\r\n\t */\r\n\t static fetchRestaurantByNeighborhood(neighborhood, callback) {\r\n\t\t// Fetch all restaurants\r\n\t\tDBHelper.fetchRestaurants((error, restaurants) => {\r\n\t\t\tif (error) {\r\n\t\t\t\tcallback(error, null);\r\n\t\t\t} else {\r\n\t\t\t\t// Filter restaurants to have only given neighborhood\r\n\t\t\t\tconst results = restaurants.filter(r => r.neighborhood == neighborhood);\r\n\t\t\t\tcallback(null, results);\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Fetch restaurants by a cuisine and a neighborhood with proper error handling.\r\n\t */\r\n\t static fetchRestaurantByCuisineAndNeighborhood(cuisine, neighborhood, callback) {\r\n\t\t// Fetch all restaurants\r\n\t\tDBHelper.fetchRestaurants((error, restaurants) => {\r\n\t\t\tif (error) {\r\n\t\t\t\tcallback(error, null);\r\n\t\t\t} else {\r\n\t\t\t\tlet results = restaurants\r\n\t\t\t\tif (cuisine != 'all') { // filter by cuisine\r\n\t\t\t\t\tresults = results.filter(r => r.cuisine_type == cuisine);\r\n\t\t\t\t}\r\n\t\t\t\tif (neighborhood != 'all') { // filter by neighborhood\r\n\t\t\t\t\tresults = results.filter(r => r.neighborhood == neighborhood);\r\n\t\t\t\t}\r\n\t\t\t\tcallback(null, results);\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Fetch all neighborhoods with proper error handling.\r\n\t */\r\n\t static fetchNeighborhoods(callback) {\r\n\t\t// Fetch all restaurants\r\n\t\tDBHelper.fetchRestaurants((error, restaurants) => {\r\n\t\t\tif (error) {\r\n\t\t\t\tcallback(error, null);\r\n\t\t\t} else {\r\n\t\t\t\t// Get all neighborhoods from all restaurants\r\n\t\t\t\tconst neighborhoods = restaurants.map((v, i) => restaurants[i].neighborhood)\r\n\t\t\t\t// Remove duplicates from neighborhoods\r\n\t\t\t\tconst uniqueNeighborhoods = neighborhoods.filter((v, i) => neighborhoods.indexOf(v) == i)\r\n\t\t\t\tcallback(null, uniqueNeighborhoods);\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Fetch restaurant reviews\r\n\t */\r\n\t static fetchRestaurantReviews(restaurant, callback) {\r\n\t \tDBHelper.submitOfflineReviews();\r\n\t \tDBHelper.dbPromise.then(db => {\r\n\t \t\tconst tx = db.transaction('restaurant-reviews');\r\n\t \t\tconst store = tx.objectStore('restaurant-reviews');\r\n\t \t\tstore.getAll().then(res => {\r\n\t \t\t\tif (res.filter(res => res.restaurant_id === restaurant.id).length > 0) {\r\n\t \t\t\t\tcallback(null, res)\r\n\t \t\t\t} else {\r\n\t \t\t\t\tfetch(`${DBHelper.DATABASE_URL}reviews/?restaurant_id=${restaurant.id}`)\r\n\t \t\t\t\t.then(res => res.json())\r\n\t \t\t\t\t.then(reviews => {\r\n\t \t\t\t\t\tthis.dbPromise.then(db => {\r\n\t \t\t\t\t\t\tconst tx = db.transaction('restaurant-reviews', 'readwrite');\r\n\t \t\t\t\t\t\tconst store = tx.objectStore('restaurant-reviews');\r\n\t \t\t\t\t\t\treviews.map(review => store.put(review))\r\n\t \t\t\t\t\t});\r\n\t \t\t\t\t\tcallback(null, reviews);\r\n\t \t\t\t\t})\r\n\t \t\t\t\t.catch(error => {\r\n\t \t\t\t\t\tcallback(error, null);\r\n\t \t\t\t\t})\r\n\t \t\t\t}\r\n\t \t\t})\r\n\t \t});\r\n\t }\r\n\r\n\t/**\r\n\t * Submit a review\r\n\t */\r\n\r\n\t static submitReview(reviewData) {\r\n\t \treturn fetch(`${DBHelper.DATABASE_URL}reviews`, {\r\n\t \t\tbody: JSON.stringify(reviewData), \r\n\t \t\tcredentials: 'same-origin', \r\n\t \t\tcache: 'no-cache', \r\n\t \t\theaders: {\r\n\t \t\t\t'content-type': 'application/json'\r\n\t \t\t},\r\n\t \t\tmode: 'cors', \r\n\t \t\tmethod: 'POST',\r\n\t \t\treferrer: 'no-referrer',\r\n\t \t\tredirect: 'follow'\r\n\t \t})\r\n\t \t.then(res => {\r\n\t \t\tres.json()\r\n\t \t\t.then(reviewData => {\r\n\t \t\t\tthis.dbPromise.then(db => {\r\n\t \t\t\t\tconst tx = db.transaction('restaurant-reviews', 'readwrite');\r\n\t \t\t\t\tconst store = tx.objectStore('restaurant-reviews');\r\n\t \t\t\t\tstore.put(reviewData);\r\n\t \t\t\t});\r\n\t \t\t\treturn reviewData;\r\n\t \t\t})\r\n\t \t})\r\n\t \t.catch(error => {\r\n\t \t\treviewData['id'] = Math.floor(Math.random() * 100000000) + 1;\r\n\r\n\t \t\tthis.dbPromise.then(db => {\r\n\t \t\t\tconst tx = db.transaction('restaurant-reviews-offline', 'readwrite');\r\n\t \t\t\tconst store = tx.objectStore('restaurant-reviews-offline');\r\n\t \t\t\tstore.put(reviewData);\r\n\t \t\t});\r\n\t \t\treturn;\r\n\t \t});\r\n\t }\r\n\r\n\t/**\r\n\t * Submit offline reviews\r\n\t */\r\n\r\n\t static submitOfflineReviews() {\r\n\t \tDBHelper.dbPromise.then(db => {\r\n\t \t\tconst tx = db.transaction('restaurant-reviews-offline');\r\n\t \t\tconst objStore = tx.objectStore('restaurant-reviews-offline');\r\n\t \t\tobjStore.getAll().then(offlineReviews => {\r\n\t \t\t\tofflineReviews.map(review => DBHelper.submitReview(review))\r\n\t \t\t\tDBHelper.resetOfflineReviews();\r\n\t \t\t})\r\n\t \t})\r\n\t }\r\n\r\n\t/**\r\n\t * Reset offline reviews\r\n\t */\r\n\t static resetOfflineReviews() {\r\n\t \tDBHelper.dbPromise.then(db => {\r\n\t \t\tconst tx = db.transaction('restaurant-reviews-offline', 'readwrite');\r\n\t \t\tconst objStore = tx.objectStore('restaurant-reviews-offline').clear();\r\n\t \t});\r\n\t }\r\n\r\n\t/**\r\n\t * Fetch all cuisines with proper error handling.\r\n\t */\r\n\t static fetchCuisines(callback) {\r\n\t\t// Fetch all restaurants\r\n\t\tDBHelper.fetchRestaurants((error, restaurants) => {\r\n\t\t\tif (error) {\r\n\t\t\t\tcallback(error, null);\r\n\t\t\t} else {\r\n\t\t\t\t// Get all cuisines from all restaurants\r\n\t\t\t\tconst cuisines = restaurants.map((v, i) => restaurants[i].cuisine_type)\r\n\t\t\t\t// Remove duplicates from cuisines\r\n\t\t\t\tconst uniqueCuisines = cuisines.filter((v, i) => cuisines.indexOf(v) == i)\r\n\t\t\t\tcallback(null, uniqueCuisines);\r\n\t\t\t}\r\n\t\t});\r\n\t}\r\n\r\n\t/**\r\n\t * Restaurant page URL.\r\n\t */\r\n\t static urlForRestaurant(restaurant) {\r\n\t \treturn (`./restaurant.html?id=${restaurant.id}`);\r\n\t }\r\n\r\n\t/**\r\n\t * Restaurant image URL.\r\n\t */\r\n\t static imageUrlForRestaurant(restaurant) {\r\n\t \treturn (`/img/${restaurant.photograph}.jpg`);\r\n\t }\r\n\r\n\t/**\r\n\t * Map marker for a restaurant.\r\n\t */\r\n\t static mapMarkerForRestaurant(restaurant, map) {\r\n\t\t// https://leafletjs.com/reference-1.3.0.html#marker  \r\n\t\tconst marker = new L.marker([restaurant.latlng.lat, restaurant.latlng.lng],\r\n\t\t\t{title: restaurant.name,\r\n\t\t\t\talt: restaurant.name,\r\n\t\t\t\turl: DBHelper.urlForRestaurant(restaurant)\r\n\t\t\t})\r\n\t\tmarker.addTo(newMap);\r\n\t\treturn marker;\r\n\t} \r\n\t/* static mapMarkerForRestaurant(restaurant, map) {\r\n\t\tconst marker = new google.maps.Marker({\r\n\t\t\tposition: restaurant.latlng,\r\n\t\t\ttitle: restaurant.name,\r\n\t\t\turl: DBHelper.urlForRestaurant(restaurant),\r\n\t\t\tmap: map,\r\n\t\t\tanimation: google.maps.Animation.DROP}\r\n\t\t);\r\n\t\treturn marker;\r\n\t} */\r\n\r\n\t/**\r\n *Toggle favourite\r\n */\r\n static faveToggle(restaurant, isFave) {\r\n \tconsole.log(isFave);\r\n \tfetch(`${DBHelper.DATABASE_URL}restaurants/${restaurant.id}/?is_favorite=${isFave}`, {\r\n \t\tmethod: 'PUT'\r\n \t})\r\n \t.then(res => res.json())\r\n \t.then(res => {\r\n \t\tconsole.log(res);\r\n \t\tDBHelper.dbPromise.then(db => {\r\n \t\t\tconst tx = db.transaction('restaurant-data', 'readwrite');\r\n \t\t\tconst store = tx.objectStore('restaurant-data');\r\n \t\t\tstore.put(res)\r\n \t\t});\r\n \t\treturn res;\r\n \t})\r\n \t.catch(error => {\r\n \t\trestaurant.is_favorite = isFave;\r\n \t\tDBHelper.dbPromise.then(db => {\r\n \t\t\tconst tx = db.transaction('restaurant-data', 'readwrite');\r\n \t\t\tconst store = tx.objectStore('restaurant-data');\r\n \t\t\tstore.put(restaurant);\r\n \t\t}).catch(error => {\r\n \t\t\tconsole.log(error);\r\n \t\t\treturn;\r\n \t\t})\r\n \t});\r\n }\r\n\r\n}"],"file":"../dbhelper.js"}